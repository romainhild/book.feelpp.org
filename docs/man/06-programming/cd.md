# Feel++ Coding Styles

This is an overview of the coding conventions we use when writing Feel++ code.

##### Table of Contents
[Naming Conventions](#naming)
[Artistic Style](#astyle)
[Indentation](#indentation)
[Declaring variables](#declvar)
[Whitespace](#whitespace)
[Braces](#braces)
[Parenthesis](#parens)
[Switch Statements](#switch)
[Line Breaks](#breaks)
[Inheritance and the `virtual` keyword](#inheritance)
[Header files](#headers)

<a name="naming">
# Naming Convention

In Feel++, we basically follow the same naming conventions as in Qt and KDE.

Class names starts with a capital. The rest is in camel case. Function names starts with a lower case, but the first letter of each successive word is capitalized.

Functions and classes should be in the `Feel` namespace.

The prefix 'set' is used for setters, but the prefix 'get' is not used for accessors. Accessors are simply named with the name of the property they access. The exception is for accessors of a boolean which may start with the prefix 'is'.

Acronyms are lowercased too. Example: Url instead of URL and isFemEnabled() instead of isFEMEnabled()

Accessors should usually be const.

This example shows some possible functions names
```
public:
    void setMatrix(const Matrix& c);
    Matrix matrix() const;
    void setDiagonal(bool b);
    bool isDiagonal() const;
```

## Reserved identifiers

 - Do not use underscores to start identifiers, see [StackOverFlow comments here](http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier/228794#228797) for the reasons

<a name="astyle"/>
# Artistic Style

Artistic Style (astyle) can be used to enforce automatically some of the rules below.
Simply run
```
sh scripts/astyle/feelpp.astyle.sh
```
The shell script is generated by cmake from the `scripts/astyle/feelpp.astyle.sh.in`

<a name="indentation"/>
# Indentation

 * 4 spaces are used for indentation
 * Spaces, not tabs!
 * Suggestion: use emacs and [http://emacswiki.org/emacs/dirvars.el dirvars.el], here is the content of `.emacs-dirvars` in top Feel++ directory
```
indent-tabs-mode: nil
tab-width: 4
c-basic-offset: 4
evaluate: (c-set-offset 'innamespace '0)
show-trailing-whitespace: t
indicate-empty-lines: t
evaluate: (add-hook 'write-file-hooks 'delete-trailing-whitespace)
```


<a name="declvar"/>
# Declaring variables

 * Declare each variable on a separate line
 * Avoid short (e.g. “a”, “rbarr”, “nughdeget”) names whenever possible
 * Single character variable names are only okay for counters and temporaries, where the purpose of the variable is obvious
 * Wait when declaring a variable until it is needed
```
// Wrong
int a, b;
char *c, *d;

// Correct
int height;
int width;
char *nameOfThis;
char *nameOfThat;
```
 * Variables and functions start with a lower-case letter. Each consecutive word in a variable’s or function's name starts with an upper-case letter
 * Avoid abbreviations
```
// Wrong
short Cntr;
char ITEM_DELIM # '\t';

// Correct
short counter;
char itemDelimiter # '\t';
```
 * Classes always start with an upper-case letter.
```
// Wrong
class meshAdaptation
{};

// Correct
class MeshAdaptation
{};
```

 * Non-static data members name of structures and classes always start with `M_` . M stands for Member. The rational behind this is for example :
   * to be able to immediately see that the data is a member of a class or a struct
   * to easily search and query-replace
```
// Wrong
class meshAdaptation
{
   std::vector<vectorN_type> directions_;
};

// Correct
class MeshAdaptation
{
   std::vector<vectorN_type> M_directions;
};
```

 * Static data members name of structures and classes always start with `S_` . S stands for Static. The rational behind this is for example :
   * to be able to immediately see that the data is a static member of a class or a struct
   * to easily search and query-replace
```
// Wrong
class meshAdaptation
{
   static std::vector<vectorN_type> directions_;
};

// Correct
class MeshAdaptation
{
   static std::vector<vectorN_type> S_directions;
};
```

<a name="whitespace"/>
# Whitespace

 * Use blank lines to group statements together where suited
 * Always use only one blank line
 * Always use a single space after a keyword and before a curly brace.
```
// Correct
if (foo)
{
}

// Wrong
if(foo)
{
}
```
 * For pointers or references, always use a single space between the type and ‘*’ or ‘&’, but no space between the ‘*’ or ‘&’ and the variable name.
```
char *x;
const std::string &myString;
const char * const y # "hello";
```
 * Surround binary operators with spaces.
 * No space after a cast.
 * Avoid C-style casts when possible.
```
// Wrong
char* blockOfMemory # (char* ) malloc(data.size());

// Correct
char *blockOfMemory # reinterpret_cast<char *>(malloc(data.size()));
```


<a name="braces"/>
# Braces

 * As a base rule, the left curly brace goes on the same line as the start of the statement:
```
// Wrong
if (codec) {
}

// Correct
if (codec)
{
}
```
 * Function implementations and class declarations always have the left brace on the start of a line:
```
static void foo(int g)
{
std::cout << g << "\n"
}

class Moo
{
};
```
 * Use curly braces when the body of a conditional statement contains more than one line, and also if a single line statement is somewhat complex.
```
// Wrong
if (address.isEmpty())
{
   return false;
}

for (int i # 0; i < 10; ++i)
{
   std::cout << "i#" << i << "\n";
}

// Correct
if (address.isEmpty())
   return false;

for (int i # 0; i < 10; ++i)
   std::cout << "i#" << i << "\n";
```
 * Exception 1: Use braces also if the parent statement covers several lines / wraps
```
// Correct
if (address.isEmpty() || !isValid()
    || !codec)
{
   return false;
}
```
 * Exception 2: Use braces also in if-then-else blocks where either the if-code or the else-code covers several lines
```
// Wrong
if (address.isEmpty())
   return false;
else
{
   std::cout << address << "\n";
   ++it;
}

// Correct
if (address.isEmpty())
{
   return false;
}
else
{
   std::cout << address << "\n";
   ++it;
}

// Wrong
if (a)
   if (b)
     ...
   else
    ...

// Correct
if (a)
{
  if (b)
   ...
  else
   ...
}
```
 * Use curly braces when the body of a conditional statement is empty
```
// Wrong
while (a);

// Correct
while (a) {}
```

<a name="parens"/>
# Parentheses

 * Use parentheses to group expressions:
```
// Wrong
if (a && b || c)

// Correct
if ((a && b) || c)

// Wrong
a + b & c

// Correct
(a + b) & c
```

<a name="switch"/>
# Switch statements

 * The case labels are in the same column as the switch
 * Every case must have a break (or return) statement at the end or a comment to indicate that there’s intentionally no break, unless another case follows immediately.
```
switch (myEnum)
{
case Value1:
    doSomething();
    break;
case Value2:
case Value3:
    doSomethingElse();
    // fall through
default:
    defaultHandling();
    break;
}
```

<a name="breaks"/>
# Line breaks

 * Keep lines shorter than 100 characters; insert breaks if necessary.
 * Commas go at the end of a broken line; operators start at the beginning of the new line. An operator at the end of the line is easy to not see if your editor is too narrow.
```
// Correct
if (longExpression
    + otherLongExpression
    + otherOtherLongExpression)
{
}

// Wrong
if (longExpression +
    otherLongExpression +
    otherOtherLongExpression)
{
}
```

<a name="inheritance"/>
# Inheritance and the `virtual` keyword

 * When reimplementing a virtual method, do not put the `virtual` keyword in the header file.

<a name="headers"/>
# Header files and double inclusion

To avoid double inclusion, wrap every header files using the following technique
````
// say we have myheader.hpp
#if !defined(FEELPP_MYHEADER_HPP)
#define FEELPP_MYHEADER_HPP 1

 // your header here...

#endif // FEELPP_MYHEADER_HPP
````
more details [here](http://en.wikipedia.org/wiki/Include_guard#Double_inclusion)
